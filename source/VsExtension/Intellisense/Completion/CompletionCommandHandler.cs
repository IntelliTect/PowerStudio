#region License

// 
// Copyright (c) 2011, PowerStudio Project Contributors
// 
// Dual-licensed under the Apache License, Version 2.0, and the Microsoft Public License (Ms-PL).
// See the file LICENSE.txt for details.
// 

#endregion

#region Using Directives

using System;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Language.Intellisense;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Editor;
using Microsoft.VisualStudio.TextManager.Interop;

#endregion

namespace PowerStudio.VsExtension.Intellisense.Completion
{
    internal class CompletionCommandHandler : IOleCommandTarget
    {
        private readonly CompletionHandlerProvider _CompletionHandlerProvider;
        private readonly IOleCommandTarget _NextCommandHandler;
        private readonly IWpfTextView _TextView;
        private ICompletionSession _Session;

        /// <summary>
        /// Initializes a new instance of the <see cref="CompletionCommandHandler"/> class.
        /// </summary>
        /// <param name="textViewAdapter">The text view adapter.</param>
        /// <param name="textView">The text view.</param>
        /// <param name="provider">The provider.</param>
        internal CompletionCommandHandler( IVsTextView textViewAdapter,
                                           IWpfTextView textView,
                                           CompletionHandlerProvider provider )
        {
            _TextView = textView;
            _CompletionHandlerProvider = provider;

            //add the command to the command chain
            textViewAdapter.AddCommandFilter( this, out _NextCommandHandler );
        }

        #region Implementation of IOleCommandTarget

        /// <summary>
        /// Queries the object for the status of one or more commands generated by user interface events.
        /// </summary>
        /// <returns>
        /// This method returns S_OK on success. Other possible return values include the following.Return codeDescriptionE_FAILThe operation failed.E_UNEXPECTEDAn unexpected error has occurred.E_POINTERThe <paramref name="prgCmds"/> argument is null.OLECMDERR_E_UNKNOWNGROUPThe <paramref name="pguidCmdGroup"/> parameter is not null but does not specify a recognized command group.
        /// </returns>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param><param name="cCmds">The number of commands in <paramref name="prgCmds"/>.</param>
        /// <param name="prgCmds">An array of <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMD"/> structures that indicate the commands for which the caller needs status information. This method fills the <paramref name="cmdf"/> member of each structure with values taken from the <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDF"/> enumeration.</param>
        /// <param name="pCmdText">An <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDTEXT"/> structure in which to return name and/or status information of a single command. This parameter can be null to indicate that the caller does not need this information.</param>
        public int QueryStatus( ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText )
        {
            return _NextCommandHandler.QueryStatus( ref pguidCmdGroup, cCmds, prgCmds, pCmdText );
        }

        /// <summary>
        /// Executes the specified command.
        /// </summary>
        /// <returns>
        /// This method returns S_OK on success. Other possible return values include the following.Return codeDescriptionOLECMDERR_E_UNKNOWNGROUPThe <paramref name="pguidCmdGroup"/> parameter is not null but does not specify a recognized command group.OLECMDERR_E_NOTSUPPORTEDThe <paramref name="nCmdID"/> parameter is not a valid command in the group identified by <paramref name="pguidCmdGroup"/>.OLECMDERR_E_DISABLEDThe command identified by <paramref name="nCmdID"/> is currently disabled and cannot be executed.OLECMDERR_E_NOHELPThe caller has asked for help on the command identified by <paramref name="nCmdID"/>, but no help is available.OLECMDERR_E_CANCELEDThe user canceled the execution of the command.
        /// </returns>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param><param name="nCmdID">The command ID.</param>
        /// <param name="nCmdexecopt">Specifies how the object should execute the command. Possible values are taken from the <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDEXECOPT"/> and <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDID_WINDOWSTATE_FLAG"/> enumerations.</param>
        /// <param name="pvaIn">The input arguments of the command.</param>
        /// <param name="pvaOut">The output arguments of the command.</param>
        public int Exec( ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut )
        {
            if ( VsShellUtilities.IsInAutomationFunction( _CompletionHandlerProvider.ServiceProvider ) )
            {
                return _NextCommandHandler.Exec( ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut );
            }
            //make a copy of this so we can look at it after forwarding some commands
            uint commandID = nCmdID;
            char typedChar = char.MinValue;
            //make sure the input is a char before getting it
            if ( pguidCmdGroup == VSConstants.VSStd2K &&
                 nCmdID == (uint) VSConstants.VSStd2KCmdID.TYPECHAR )
            {
                typedChar = (char) (ushort) Marshal.GetObjectForNativeVariant( pvaIn );
            }

            //check for a commit character
            if ( nCmdID == (uint) VSConstants.VSStd2KCmdID.RETURN
                 || nCmdID == (uint) VSConstants.VSStd2KCmdID.TAB
                 ||
                 ( char.IsWhiteSpace( typedChar ) || ( char.IsPunctuation( typedChar ) && typedChar != '-' ) ) )
            {
                //check for a a selection
                if ( _Session != null &&
                     !_Session.IsDismissed )
                {
                    //if the selection is fully selected, commit the current session
                    if ( _Session.SelectedCompletionSet.SelectionStatus.IsSelected )
                    {
                        _Session.Commit();
                        //also, don't add the character to the buffer
                        return VSConstants.S_OK;
                    }
                    //if there is no selection, dismiss the session
                    _Session.Dismiss();
                }
            }

            //pass along the command so the char is added to the buffer
            int retVal = _NextCommandHandler.Exec( ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut );
            bool handled = false;
            if ( !typedChar.Equals( char.MinValue ) &&
                 ( char.IsLetterOrDigit( typedChar ) || typedChar == '$' || typedChar == '-' ) )
            {
                if ( _Session == null ||
                     _Session.IsDismissed ) // If there is no active session, bring up completion
                {
                    TriggerCompletion();
                    _Session.Filter();
                }
                else //the completion session is already active, so just filter
                {
                    _Session.Filter();
                }
                handled = true;
            }
            else if ( commandID == (uint) VSConstants.VSStd2KCmdID.BACKSPACE //redo the filter if there is a deletion
                      ||
                      commandID == (uint) VSConstants.VSStd2KCmdID.DELETE )
            {
                if ( _Session != null &&
                     !_Session.IsDismissed )
                {
                    _Session.Filter();
                }
                handled = true;
            }
            return handled ? VSConstants.S_OK : retVal;
        }

        #endregion

        private bool TriggerCompletion()
        {
            //the caret must be in a non-projection location 
            SnapshotPoint? caretPoint =
                    _TextView.Caret.Position.Point
                            .GetPoint( textBuffer => !IsProjection( textBuffer ), PositionAffinity.Predecessor );
            if ( !caretPoint.HasValue )
            {
                return false;
            }

            _Session = _CompletionHandlerProvider.CompletionBroker.CreateCompletionSession
                    ( _TextView,
                      caretPoint.Value.Snapshot.CreateTrackingPoint( caretPoint.Value.Position,
                                                                     PointTrackingMode.Positive ),
                      true );

            //subscribe to the Dismissed event on the session 
            _Session.Dismissed += OnSessionDismissed;
            _Session.Start();

            return true;
        }

        private static bool IsProjection( ITextBuffer match )
        {
            return match.ContentType.IsOfType( "projection" );
        }

        private void OnSessionDismissed( object sender, EventArgs e )
        {
            _Session.Dismissed -= OnSessionDismissed;
            _Session = null;
        }
    }
}