%using Microsoft.VisualStudio.TextManager.Interop
%namespace Babel.Parser
%valuetype LexValue
%partial

/* %expect 5 */


%union {
	public string str;
}


%{
	ErrorHandler handler = null;
	public void SetHandler(ErrorHandler hdlr) { handler = hdlr; }
	internal void CallHdlr(string msg, LexLocation val)
	{
		handler.AddError(msg, val.sLin, val.sCol, val.eCol - val.sCol);
	}
	internal TextSpan MkTSpan(LexLocation s) { return TextSpan(s.sLin, s.sCol, s.eLin, s.eCol); }

	internal void Match(LexLocation lh, LexLocation rh) 
	{
		DefineMatch(MkTSpan(lh), MkTSpan(rh)); 
	}
%}


// keywords
%token BEGIN BREAK CATCH CONTINUE DATA DO DYNAMICPARAM ELSE ELSEIF END EXIT FILTER FINALLY
%token FOR FOREACH FROM FUNCTION IF IN PARAM PROCESS RETURN SWITCH THROW TRAP TRY UNTIL WHILE

// comprison operators
%token COEQ CONE COGE COGT COLT COLE COIEQ COINE COIGE COIGT COILT COILE COCEQ COCNE COCGE COCGT COCLT COCLE
%token COLIKE CONOTLIKE COMATCH CONOTMATCH COILIKE COINOTLIKE COIMATCH COINOTMATCH COCLIKE COCNOTLIKE COCMATCH COCNOTMATCH
%token COCONTAINS CONOTCONTAINS COICONTAINS COINOTCONTAINS COCCONTAINS COCNOTCONTAINS COISNOT COIS COAS
%token COREPLACE COIREPLACE COCREPLACE

// logical operators
%token LOAND LOOR

// Bitwise operators
%token BOBAND BOBOR

%token PLUSEQ MINUSEQ TIMESEQ DIVEQ MODEQ

%token IDENTIFIER NUMBER CMDLET DOLLAR VARIABLE

  // %token ',' ';' '(' ')' '{' '}' '=' 
  // %token '+' '-' '*' '/' '!' '&' '|' '^'

// binary operators
%token DOT COLON MINUS PLUS DIV MULT EXP MOD

%token AMPAMP BARBAR STRING
%token maxParseToken 
%token LEX_WHITE LEX_COMMENT LEX_ERROR

%left '*' '/'
%left '+' '-'
%%

Program
	: Declarations 
	;

Declarations
	: Declaration Declarations
	| Declaration error         { CallHdlr("Expected Declaration", @2); }
	| /* empty */
	;
	
Declaration   /* might need an init action for symtab init here */
	: Declaration_
	;

Declaration_
	: IDENTIFIER ParenParams Block
	| SimpleDeclaration    
	;


SimpleDeclarations1
	: SimpleDeclaration SimpleDeclarations1
	| SimpleDeclaration 
	;

SimpleDeclaration
	: SemiDeclaration ';'
	| SemiDeclaration error ';'     { CallHdlr("Bad declaration, expected ';'", @2); }
	;


SemiDeclaration
	: SemiDeclaration ',' IDENTIFIER
	| IDENTIFIER  
	;


Params1
	: Params1 ',' IDENTIFIER 
	| IDENTIFIER            
	;

ParenParams
	:  '(' ')'                   { Match(@1, @2); }
	|  '(' Params1 ')'           { Match(@1, @3); }
	|  '(' Params1 error         { CallHdlr("unmatched parentheses", @3); }
	|  '(' error ')'             { $$ = $3;
								   CallHdlr("error in params", @2); }
	;

Block
	: OpenBlock CloseBlock      { Match(@1, @2); }
	| OpenBlock BlockContent1 CloseBlock
								{ Match(@1, @3); }
	| OpenBlock BlockContent1 error 
								{ CallHdlr("missing '}'", @3); }
	| OpenBlock error CloseBlock
								{ Match(@1, @3); }
	;

OpenBlock
	: '{'                       { /*  */ }
	;

CloseBlock
	: '}'                       { /*  */ }
	;

BlockContent1
	: SimpleDeclarations1 Statements1
	| SimpleDeclarations1
	| Statements1
	;

Statements1
	: Statement Statements1
	| Statement
	;

Statement
	: SemiStatement ';'
	| SemiStatement error ';'       { CallHdlr("expected ';'", @2); } 
  
	| WHILE ParenExprAlways Statement
	| FOR ForHeader Statement
	| IF ParenExprAlways Statement
	| IF ParenExprAlways Statement ELSE Statement
								{ /*  */ }
	| Block
	;

ParenExprAlways
	: ParenExpr
	| error ')'                 { CallHdlr("error in expr", @1); }
	| error                     { CallHdlr("error in expr", @1); }
	;

ParenExpr
	: '(' Expr ')'              { Match(@1, @3); }
	| '(' Expr error            { CallHdlr("unmatched parentheses", @3); }
	;

ForHeader
	: '(' ForBlock ')'          { Match(@1, @3); }
	| '(' ForBlock error        { CallHdlr("unmatched parentheses", @3); }
	| '(' error ')'             { Match(@1, @3); 
								  CallHdlr("error in for", @2); }
	;

ForBlock
	: AssignExpr ';' Expr ';' AssignExpr
	;

SemiStatement
	: AssignExpr 
	| RETURN Expr 
	| BREAK 
	| CONTINUE     
	;
	
Arguments1
	: Expr ',' Arguments1
	| Expr
	;

ParenArguments
	: StartArg EndArg                { Match(@1, @2); } 
	| StartArg Arguments1 EndArg     { Match(@1, @3); }
	| StartArg Arguments1 error      { CallHdlr("unmatched parentheses", @3); }
	;

StartArg
	: '('                       { /*  */ }
	;

EndArg
	: ')'                       { /*  */ }
	;    

AssignExpr
	: Identifier '=' Expr   
	| Expr
	;

Expr
	: RelExpr BoolOp Expr
	| RelExpr
	| RelExpr RelExpr           { CallHdlr("error in relational expression", @2); }
	| error '}'                 { CallHdlr("unexpected symbol skipping to '}'", @1); }
	;

BoolOp
	: AMPAMP | BARBAR 
	;

RelExpr
	: BitExpr RelOp RelExpr
	| BitExpr
	;

RelOp
	: COGT | COGE | COLT | COLE
	;
	 
BitExpr
	: AddExpr BitOp BitExpr
	| AddExpr
	;

BitOp
	: '|' | '&' | '^'
	;


AddExpr
	: MulExpr AddOp AddExpr
	| MulExpr
	;

AddOp
	: '+' | '-'
	;


MulExpr
	: PreExpr MulOp MulExpr
	| PreExpr 
	;

MulOp 
	: '*' | '/'
	;

PreExpr
	: PrefixOp Factor
	| Factor
	;

PrefixOp
	: '!' 
	;


Factor
	: Identifier ParenArguments 
	| Identifier
	| NUMBER
	| ParenExpr
	;     
	
Identifier
	: IDENTIFIER				  { /*  */ }
	| Identifier '.' IDENTIFIER	  { /*  */ }	
	| Identifier '.' error        { CallHdlr("expected identifier", @3); }
	;
	
%%



