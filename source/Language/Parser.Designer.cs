// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.4.4
// Machine:  WIN-O4E9B4BK3TB
// DateTime: 3/25/2011 9:06:33 PM
// UserName: idavis
// Input file <parser.y - 3/25/2011 9:06:28 PM>

// options: babel lines diagnose & report gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using Microsoft.VisualStudio.TextManager.Interop;
using PowerStudio.Resources;

namespace PowerStudio.Language
{
public enum Tokens {error=48,
    EOF=49,BEGIN=50,BREAK=51,CATCH=52,CONTINUE=53,DATA=54,
    DO=55,DYNAMICPARAM=56,ELSE=57,ELSEIF=58,END=59,EXIT=60,
    FILTER=61,FINALLY=62,FOR=63,FOREACH=64,FROM=65,FUNCTION=66,
    IF=67,IN=68,PARAM=69,PROCESS=70,RETURN=71,SWITCH=72,
    THROW=73,TRAP=74,TRY=75,UNTIL=76,WHILE=77,COEQ=78,
    CONE=79,COGE=80,COGT=81,COLT=82,COLE=83,COIEQ=84,
    COINE=85,COIGE=86,COIGT=87,COILT=88,COILE=89,COCEQ=90,
    COCNE=91,COCGE=92,COCGT=93,COCLT=94,COCLE=95,COLIKE=96,
    CONOTLIKE=97,COMATCH=98,CONOTMATCH=99,COILIKE=100,COINOTLIKE=101,COIMATCH=102,
    COINOTMATCH=103,COCLIKE=104,COCNOTLIKE=105,COCMATCH=106,COCNOTMATCH=107,COCONTAINS=108,
    CONOTCONTAINS=109,COICONTAINS=110,COINOTCONTAINS=111,COCCONTAINS=112,COCNOTCONTAINS=113,COISNOT=114,
    COIS=115,COAS=116,COREPLACE=117,COIREPLACE=118,COCREPLACE=119,LOAND=120,
    LOOR=121,BOBAND=122,BOBOR=123,PLUSEQ=124,MINUSEQ=125,TIMESEQ=126,
    DIVEQ=127,MODEQ=128,IDENTIFIER=129,NUMBER=130,CMDLET=131,DOLLAR=132,
    VARIABLE=133,DOT=134,COLON=135,MINUS=136,PLUS=137,DIV=138,
    MULT=139,EXP=140,MOD=141,AMPAMP=142,BARBAR=143,STRING=144,
    CAST=145,LEX_WHITE=146,COMMENT=147,LEX_ERROR=148,STATEMENTSEPARATOR=149,ASSIGNMENTOPERATOR=150,
    maxParseToken=151};

public partial struct LexValue
#line 10 "parser.y"
{
#line 11 "parser.y"
	public string str;
#line 12 "parser.y"
}
// Abstract base class for GPLEX scanners
public abstract class ScanBase : AbstractScanner<LexValue,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }

  protected abstract int CurrentSc { get; set; }
  //
  // Override the virtual EolState property if the scanner state is more
  // complicated then a simple copy of the current start state ordinal
  //
  public virtual int EolState { get { return CurrentSc; } set { CurrentSc = value; } }
}

// Interface class for 'colorizing' scanners
public interface IColorScan {
  void SetSource(string source, int offset);
  int GetNext(ref int state, out int start, out int end);
}

public partial class Parser: ShiftReduceParser<LexValue, LexLocation>
{
  // Verbatim content from parser.y - 3/25/2011 9:06:28 PM
#line 16 "parser.y"
	IErrorHandler errorHandler = null;
#line 17 "parser.y"
	
#line 18 "parser.y"
	public void SetHandler(IErrorHandler errorHandler) { this.errorHandler = errorHandler; }
#line 19 "parser.y"
	
#line 20 "parser.y"
	internal void HandleError(string message, LexLocation lexLocation)
#line 21 "parser.y"
	{
#line 22 "parser.y"
		errorHandler.AddError(message, lexLocation.StartLine, lexLocation.StartColumn, lexLocation.EndColumn - lexLocation.StartColumn);
#line 23 "parser.y"
	}
#line 24 "parser.y"
	
#line 25 "parser.y"
	internal TextSpan ToSpan(LexLocation lexLocation) { return TextSpan(lexLocation.StartLine, lexLocation.StartColumn, lexLocation.EndLine, lexLocation.EndColumn); }
#line 26 "parser.y"

#line 27 "parser.y"
	internal void Match(LexLocation lhs, LexLocation rhs) 
#line 28 "parser.y"
	{
#line 29 "parser.y"
		DefineMatch(ToSpan(lhs), ToSpan(rhs)); 
#line 30 "parser.y"
	}
  // End verbatim content from parser.y - 3/25/2011 9:06:28 PM

#pragma warning disable 649
  private static Dictionary<int, string> aliasses;
#pragma warning restore 649
  private static Rule[] rules = new Rule[3];
  private static State[] states = new State[3];
  private static string[] nonTerms = new string[] {
      "Program", "$accept", };

  static Parser() {
    states[0] = new State(-2,new int[]{-1,1});
    states[1] = new State(new int[]{49,2});
    states[2] = new State(-1);

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-2, new int[]{-1,49});
    rules[2] = new Rule(-1, new int[]{});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
    switch (action)
    {
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

#line 75 "parser.y"

#line 76 "parser.y"

#line 77 "parser.y"

}
}
